* **문제** : 프로그래머스 - 게임 맵 최단거리
* **난이도** : 레벨 2
* **문제 유형** : BFS (격자 최단거리)
* **푼 언어** : Java

## 01. 문제 설명

`n x m` 크기의 맵에서 시작점 `(1,1)`에서 도착점 `(n,m)`까지 **동/서/남/북** 네 방향으로만 이동할 수 있습니다.
칸의 값이 `1`이면 통로, `0`이면 벽입니다. 시작과 도착을 포함하여 **지나가는 칸의 개수의 최솟값**을 구하세요.
도착 불가능하면 `-1`을 반환합니다.

### 제한사항

* `1 ≤ n, m ≤ 100` (단, `n = m = 1`은 입력으로 주어지지 않음)
* `maps[i][j] ∈ {0, 1}`
* 시작은 좌상단 `(1,1)`, 도착은 우하단 `(n,m)`

### 입출력 예

* `[[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,1],[0,0,0,0,1]] → 11`
* `[[1,0,1,1,1],[1,0,1,0,1],[1,0,1,1,1],[1,1,1,0,0],[0,0,0,0,1]] → -1`

---

## 02. 문제 풀이

1. **방법 (나의 풀이)**

* **핵심 아이디어** : **BFS**는 모든 간선 비용이 동일(한 칸 이동 = 1)일 때 **최단거리**를 보장합니다.
* **상태 정의** : `(x, y)` 현재 위치와, 그 칸까지의 최단 거리 `dist[x][y]`
* **방문/거리 관리** : `dist` 배열을 0으로 초기화하고, 방문 시 `이전 거리 + 1`로 갱신 (방문 체크 겸용)
* **종료 조건** : 탐색 중 `(n-1, m-1)`에 도달하면 해당 `dist` 반환
* **예외 처리** : 시작/도착이 벽이면 곧바로 `-1`

2. **대안**

* DFS(재귀/스택)도 가능하지만, 동일 가중치 그래프에서 **최단거리**를 안정적으로 구하는 건 BFS가 정석입니다.

### 코드 — BFS (Queue 기반, 반복문)

```java
import java.util.*;

class Solution {
    public int solution(int[][] maps) {
        int n = maps.length;
        int m = maps[0].length;

        // 시작/도착이 막혀 있으면 불가능
        if (maps[0][0] == 0 || maps[n-1][m-1] == 0) return -1;

        int[][] dist = new int[n][m];
        dist[0][0] = 1; // 시작 칸 포함해서 1부터

        int[] dx = {1, -1, 0, 0}; // 남, 북, 동, 서
        int[] dy = {0, 0, 1, -1};

        Deque<int[]> q = new ArrayDeque<>();
        q.offer(new int[]{0, 0});

        while (!q.isEmpty()) {
            int[] cur = q.poll();
            int x = cur[0], y = cur[1];

            // 도착하면 즉시 반환 (BFS 특성상 최초 도달이 최단)
            if (x == n - 1 && y == m - 1) {
                return dist[x][y];
            }

            for (int d = 0; d < 4; d++) {
                int nx = x + dx[d];
                int ny = y + dy[d];

                // 범위 밖
                if (nx < 0 || nx >= n || ny < 0 || ny >= m) continue;
                // 벽이거나 이미 방문
                if (maps[nx][ny] == 0 || dist[nx][ny] != 0) continue;

                dist[nx][ny] = dist[x][y] + 1;
                q.offer(new int[]{nx, ny});
            }
        }

        // 끝까지 못 갔으면 불가능
        return -1;
    }
}
```


---

## 03. 회고

* 시작/도착이 벽인 경우를 초기에 바로 걸러야 불필요한 탐색을 피할 수 있습니다.
* `dist`를 방문 배열 겸용으로 쓰면 코드가 간결해지고, 시작을 1로 세팅하면 “지나간 칸 수”를 반환값과 바로 일치시킬 수 있어 실수가 줄었음
