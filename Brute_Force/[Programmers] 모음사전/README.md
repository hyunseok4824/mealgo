# 모음사전 (프로그래머스)

* **문제** : 프로그래머스 - 모음사전
* **난이도** : 레벨 2
* **문제 유형** : 완전탐색 / 수학적 규칙
* **푼 언어** : Java

---

## 01. 문제 설명

사전에 알파벳 모음 `'A', 'E', 'I', 'O', 'U'`만을 사용하여 만들 수 있는,
길이 1 이상 5 이하의 모든 단어가 수록되어 있다.

사전에서의 순서는 다음과 같다.

```
A, AA, AAA, AAAA, AAAAA, AAAAE, AAAAI, ...
```

주어진 단어 `word`가 사전에서 **몇 번째 단어인지**를 구해야 한다.

---

### 입출력 예시

| word      | return |
| --------- | ------ |
| `"AAAAE"` | 6      |
| `"AAAE"`  | 10     |
| `"I"`     | 1563   |
| `"EIO"`   | 1189   |

---

## 02. 문제 풀이

### 1️⃣ 아이디어

1. 사전은 DFS(깊이 우선) 순서로 단어를 만들어 나가는 구조이다.
   즉, `"A" → "AA" → "AAA" → "AAAA" → "AAAAA" → "AAAAE" ...`
2. 하지만 실제로 단어를 전부 생성하지 않고, **자리마다의 가중치(weight)** 를 계산해서
   단어의 순서를 수학적으로 구할 수 있다.

---

### 2️⃣ 자리별 가중치

각 자리에서 만들 수 있는 단어의 개수는 다음과 같다.

| 자리  | 계산식                   | 값   |
| --- | --------------------- | --- |
| 1번째 | 5⁴ + 5³ + 5² + 5¹ + 1 | 781 |
| 2번째 | 5³ + 5² + 5¹ + 1      | 156 |
| 3번째 | 5² + 5¹ + 1           | 31  |
| 4번째 | 5¹ + 1                | 6   |
| 5번째 | 1                     | 1   |

따라서

```
단어 순서 = Σ(해당 자리의 문자 인덱스 × 가중치) + 자리 수 만큼의 1
```

---

### 3️⃣ 예시

#### "EIO"

| 문자     | 인덱스 | 계산식       | 결과       |
| ------ | --- | --------- | -------- |
| E      | 1   | 1×781 + 1 | 782      |
| I      | 2   | 2×156 + 1 | 313      |
| O      | 3   | 3×31 + 1  | 94       |
| **합계** |     |           | **1189** |

---

### 4️⃣ 코드

```java
class Solution {
    public int solution(String word) {
        int[] weights = {781, 156, 31, 6, 1};
        char[] vowels = {'A', 'E', 'I', 'O', 'U'};
        int answer = 0;

        for (int i = 0; i < word.length(); i++) {
            int idx = 0;
            for (int j = 0; j < vowels.length; j++) {
                if (word.charAt(i) == vowels[j]) {
                    idx = j;
                    break;
                }
            }
            answer += idx * weights[i] + 1;
        }
        return answer;
    }
}
```

---

## 03. 회고

* 처음엔 BFS로 사전 단어를 순차적으로 생성하려 했지만,
  문제의 순서는 깊이우선(DFS) 방식이었기 때문에 순서가 맞지 않았다.

